/*
 * generated by Xtext 2.34.0
 */
package at.jku.isse.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class OCLXGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.Model");
		private final Assignment cConstraintsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cConstraintsConstraintParserRuleCall_0 = (RuleCall)cConstraintsAssignment.eContents().get(0);
		
		//Model:
		//    constraints+=Constraint*;
		@Override public ParserRule getRule() { return rule; }
		
		//constraints+=Constraint*
		public Assignment getConstraintsAssignment() { return cConstraintsAssignment; }
		
		//Constraint
		public RuleCall getConstraintsConstraintParserRuleCall_0() { return cConstraintsConstraintParserRuleCall_0; }
	}
	public class ConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.Constraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cRuleKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cDescriptionKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cDescriptionAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cDescriptionDESCRIPTIONTerminalRuleCall_3_1_0 = (RuleCall)cDescriptionAssignment_3_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cIsKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Keyword cOverrulableKeyword_4_1 = (Keyword)cGroup_4.eContents().get(1);
		private final Assignment cOverrulableAssignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cOverrulableBooleanLiteralExpParserRuleCall_4_2_0 = (RuleCall)cOverrulableAssignment_4_2.eContents().get(0);
		private final Keyword cContextKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cContextAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cContextContextParserRuleCall_6_0 = (RuleCall)cContextAssignment_6.eContents().get(0);
		private final Keyword cExpressionKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cExpressionAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cExpressionExpParserRuleCall_8_0 = (RuleCall)cExpressionAssignment_8.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		//Constraint:
		//    'rule' name=ID '{'
		//        ('description:'  description=DESCRIPTION )?
		//        ('is' 'overrulable:' overrulable?=BooleanLiteralExp)?
		//        'context:' context=Context
		//        'expression:' expression=Exp
		//    "}";
		@Override public ParserRule getRule() { return rule; }
		
		//'rule' name=ID '{'
		//    ('description:'  description=DESCRIPTION )?
		//    ('is' 'overrulable:' overrulable?=BooleanLiteralExp)?
		//    'context:' context=Context
		//    'expression:' expression=Exp
		//"}"
		public Group getGroup() { return cGroup; }
		
		//'rule'
		public Keyword getRuleKeyword_0() { return cRuleKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }
		
		//('description:'  description=DESCRIPTION )?
		public Group getGroup_3() { return cGroup_3; }
		
		//'description:'
		public Keyword getDescriptionKeyword_3_0() { return cDescriptionKeyword_3_0; }
		
		//description=DESCRIPTION
		public Assignment getDescriptionAssignment_3_1() { return cDescriptionAssignment_3_1; }
		
		//DESCRIPTION
		public RuleCall getDescriptionDESCRIPTIONTerminalRuleCall_3_1_0() { return cDescriptionDESCRIPTIONTerminalRuleCall_3_1_0; }
		
		//('is' 'overrulable:' overrulable?=BooleanLiteralExp)?
		public Group getGroup_4() { return cGroup_4; }
		
		//'is'
		public Keyword getIsKeyword_4_0() { return cIsKeyword_4_0; }
		
		//'overrulable:'
		public Keyword getOverrulableKeyword_4_1() { return cOverrulableKeyword_4_1; }
		
		//overrulable?=BooleanLiteralExp
		public Assignment getOverrulableAssignment_4_2() { return cOverrulableAssignment_4_2; }
		
		//BooleanLiteralExp
		public RuleCall getOverrulableBooleanLiteralExpParserRuleCall_4_2_0() { return cOverrulableBooleanLiteralExpParserRuleCall_4_2_0; }
		
		//'context:'
		public Keyword getContextKeyword_5() { return cContextKeyword_5; }
		
		//context=Context
		public Assignment getContextAssignment_6() { return cContextAssignment_6; }
		
		//Context
		public RuleCall getContextContextParserRuleCall_6_0() { return cContextContextParserRuleCall_6_0; }
		
		//'expression:'
		public Keyword getExpressionKeyword_7() { return cExpressionKeyword_7; }
		
		//expression=Exp
		public Assignment getExpressionAssignment_8() { return cExpressionAssignment_8; }
		
		//Exp
		public RuleCall getExpressionExpParserRuleCall_8_0() { return cExpressionExpParserRuleCall_8_0; }
		
		//"}"
		public Keyword getRightCurlyBracketKeyword_9() { return cRightCurlyBracketKeyword_9; }
	}
	public class QualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.QualifiedName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//QualifiedName:
		//    ID ('.' ID)*;
		@Override public ParserRule getRule() { return rule; }
		
		//ID ('.' ID)*
		public Group getGroup() { return cGroup; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//('.' ID)*
		public Group getGroup_1() { return cGroup_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }
	}
	public class SimpleNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.SimpleName");
		private final RuleCall cIDTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//SimpleName:
		//    ID;
		@Override public ParserRule getRule() { return rule; }
		
		//ID
		public RuleCall getIDTerminalRuleCall() { return cIDTerminalRuleCall; }
	}
	public class ContextElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.Context");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameQualifiedNameParserRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//Context:
		//    name = QualifiedName
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name = QualifiedName
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_0() { return cNameQualifiedNameParserRuleCall_0; }
	}
	public class ExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.Exp");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrefixedExpParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cInfixExpExpressionsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorsBinaryOperatorParserRuleCall_1_1_0 = (RuleCall)cOperatorsAssignment_1_1.eContents().get(0);
		private final Assignment cExpressionsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExpressionsPrefixedExpParserRuleCall_1_2_0 = (RuleCall)cExpressionsAssignment_1_2.eContents().get(0);
		private final Group cGroup_1_3 = (Group)cGroup_1.eContents().get(3);
		private final Assignment cOperatorsAssignment_1_3_0 = (Assignment)cGroup_1_3.eContents().get(0);
		private final RuleCall cOperatorsBinaryOperatorParserRuleCall_1_3_0_0 = (RuleCall)cOperatorsAssignment_1_3_0.eContents().get(0);
		private final Assignment cExpressionsAssignment_1_3_1 = (Assignment)cGroup_1_3.eContents().get(1);
		private final RuleCall cExpressionsPrefixedExpParserRuleCall_1_3_1_0 = (RuleCall)cExpressionsAssignment_1_3_1.eContents().get(0);
		
		//Exp returns Exp: //if there are more expressions, make sure that the initial PrefixedExp in the following line is added to the list of expressions via 'current'
		//    PrefixedExp (
		//        {InfixExp.expressions+=current} operators+=BinaryOperator expressions+=PrefixedExp
		//        (operators+=BinaryOperator expressions+=PrefixedExp)*
		//    )?;
		@Override public ParserRule getRule() { return rule; }
		
		////if there are more expressions, make sure that the initial PrefixedExp in the following line is added to the list of expressions via 'current'
		//   PrefixedExp (
		//       {InfixExp.expressions+=current} operators+=BinaryOperator expressions+=PrefixedExp
		//       (operators+=BinaryOperator expressions+=PrefixedExp)*
		//   )?
		public Group getGroup() { return cGroup; }
		
		////if there are more expressions, make sure that the initial PrefixedExp in the following line is added to the list of expressions via 'current'
		//   PrefixedExp
		public RuleCall getPrefixedExpParserRuleCall_0() { return cPrefixedExpParserRuleCall_0; }
		
		//(
		//       {InfixExp.expressions+=current} operators+=BinaryOperator expressions+=PrefixedExp
		//       (operators+=BinaryOperator expressions+=PrefixedExp)*
		//   )?
		public Group getGroup_1() { return cGroup_1; }
		
		//{InfixExp.expressions+=current}
		public Action getInfixExpExpressionsAction_1_0() { return cInfixExpExpressionsAction_1_0; }
		
		//operators+=BinaryOperator
		public Assignment getOperatorsAssignment_1_1() { return cOperatorsAssignment_1_1; }
		
		//BinaryOperator
		public RuleCall getOperatorsBinaryOperatorParserRuleCall_1_1_0() { return cOperatorsBinaryOperatorParserRuleCall_1_1_0; }
		
		//expressions+=PrefixedExp
		public Assignment getExpressionsAssignment_1_2() { return cExpressionsAssignment_1_2; }
		
		//PrefixedExp
		public RuleCall getExpressionsPrefixedExpParserRuleCall_1_2_0() { return cExpressionsPrefixedExpParserRuleCall_1_2_0; }
		
		//(operators+=BinaryOperator expressions+=PrefixedExp)*
		public Group getGroup_1_3() { return cGroup_1_3; }
		
		//operators+=BinaryOperator
		public Assignment getOperatorsAssignment_1_3_0() { return cOperatorsAssignment_1_3_0; }
		
		//BinaryOperator
		public RuleCall getOperatorsBinaryOperatorParserRuleCall_1_3_0_0() { return cOperatorsBinaryOperatorParserRuleCall_1_3_0_0; }
		
		//expressions+=PrefixedExp
		public Assignment getExpressionsAssignment_1_3_1() { return cExpressionsAssignment_1_3_1; }
		
		//PrefixedExp
		public RuleCall getExpressionsPrefixedExpParserRuleCall_1_3_1_0() { return cExpressionsPrefixedExpParserRuleCall_1_3_1_0; }
	}
	public class PrefixedExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.PrefixedExp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cPrefixExpAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cOperatorAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cOperatorUnaryOperatorParserRuleCall_0_1_0 = (RuleCall)cOperatorAssignment_0_1.eContents().get(0);
		private final Assignment cExpressionAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cExpressionPrimaryExpParserRuleCall_0_2_0 = (RuleCall)cExpressionAssignment_0_2.eContents().get(0);
		private final RuleCall cPrimaryExpParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		///*
		// * Expression can start with a varref (that might be prefixed with a 'not' or '-' )
		// *
		// */
		//PrefixedExp returns Exp:
		//    ({PrefixExp} operator=UnaryOperator expression=PrimaryExp)
		//    |     PrimaryExp
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//({PrefixExp} operator=UnaryOperator expression=PrimaryExp)
		//|     PrimaryExp
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//({PrefixExp} operator=UnaryOperator expression=PrimaryExp)
		public Group getGroup_0() { return cGroup_0; }
		
		//{PrefixExp}
		public Action getPrefixExpAction_0_0() { return cPrefixExpAction_0_0; }
		
		//operator=UnaryOperator
		public Assignment getOperatorAssignment_0_1() { return cOperatorAssignment_0_1; }
		
		//UnaryOperator
		public RuleCall getOperatorUnaryOperatorParserRuleCall_0_1_0() { return cOperatorUnaryOperatorParserRuleCall_0_1_0; }
		
		//expression=PrimaryExp
		public Assignment getExpressionAssignment_0_2() { return cExpressionAssignment_0_2; }
		
		//PrimaryExp
		public RuleCall getExpressionPrimaryExpParserRuleCall_0_2_0() { return cExpressionPrimaryExpParserRuleCall_0_2_0; }
		
		//PrimaryExp
		public RuleCall getPrimaryExpParserRuleCall_1() { return cPrimaryExpParserRuleCall_1; }
	}
	public class BinaryOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.BinaryOperator");
		private final RuleCall cInfixOperatorParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//BinaryOperator returns BinaryOperator: // we need to split these, as after a navigation we can no longer use a var ref, while we cannot use a property access upon an infix operator
		//    InfixOperator // | NavigationOperator
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//// we need to split these, as after a navigation we can no longer use a var ref, while we cannot use a property access upon an infix operator
		//   InfixOperator
		public RuleCall getInfixOperatorParserRuleCall() { return cInfixOperatorParserRuleCall; }
	}
	public class InfixOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.InfixOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBooleanOperatorParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMathOperatorParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//InfixOperator returns BinaryOperator:
		//    BooleanOperator | MathOperator;
		@Override public ParserRule getRule() { return rule; }
		
		//BooleanOperator | MathOperator
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BooleanOperator
		public RuleCall getBooleanOperatorParserRuleCall_0() { return cBooleanOperatorParserRuleCall_0; }
		
		//MathOperator
		public RuleCall getMathOperatorParserRuleCall_1() { return cMathOperatorParserRuleCall_1; }
	}
	public class BooleanOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.BooleanOperator");
		private final Assignment cOpAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cOpAlternatives_0 = (Alternatives)cOpAssignment.eContents().get(0);
		private final Keyword cOpGreaterThanSignKeyword_0_0 = (Keyword)cOpAlternatives_0.eContents().get(0);
		private final Keyword cOpLessThanSignKeyword_0_1 = (Keyword)cOpAlternatives_0.eContents().get(1);
		private final Keyword cOpGreaterThanSignEqualsSignKeyword_0_2 = (Keyword)cOpAlternatives_0.eContents().get(2);
		private final Keyword cOpLessThanSignEqualsSignKeyword_0_3 = (Keyword)cOpAlternatives_0.eContents().get(3);
		private final Keyword cOpEqualsSignKeyword_0_4 = (Keyword)cOpAlternatives_0.eContents().get(4);
		private final Keyword cOpLessThanSignGreaterThanSignKeyword_0_5 = (Keyword)cOpAlternatives_0.eContents().get(5);
		private final Keyword cOpAndKeyword_0_6 = (Keyword)cOpAlternatives_0.eContents().get(6);
		private final Keyword cOpOrKeyword_0_7 = (Keyword)cOpAlternatives_0.eContents().get(7);
		private final Keyword cOpXorKeyword_0_8 = (Keyword)cOpAlternatives_0.eContents().get(8);
		private final Keyword cOpImpliesKeyword_0_9 = (Keyword)cOpAlternatives_0.eContents().get(9);
		
		//BooleanOperator returns BooleanOperator:
		//    op=('>' | '<' | '>=' | '<=' | '=' | '<>' | 'and' | 'or' | 'xor' | 'implies');
		@Override public ParserRule getRule() { return rule; }
		
		//op=('>' | '<' | '>=' | '<=' | '=' | '<>' | 'and' | 'or' | 'xor' | 'implies')
		public Assignment getOpAssignment() { return cOpAssignment; }
		
		//('>' | '<' | '>=' | '<=' | '=' | '<>' | 'and' | 'or' | 'xor' | 'implies')
		public Alternatives getOpAlternatives_0() { return cOpAlternatives_0; }
		
		//'>'
		public Keyword getOpGreaterThanSignKeyword_0_0() { return cOpGreaterThanSignKeyword_0_0; }
		
		//'<'
		public Keyword getOpLessThanSignKeyword_0_1() { return cOpLessThanSignKeyword_0_1; }
		
		//'>='
		public Keyword getOpGreaterThanSignEqualsSignKeyword_0_2() { return cOpGreaterThanSignEqualsSignKeyword_0_2; }
		
		//'<='
		public Keyword getOpLessThanSignEqualsSignKeyword_0_3() { return cOpLessThanSignEqualsSignKeyword_0_3; }
		
		//'='
		public Keyword getOpEqualsSignKeyword_0_4() { return cOpEqualsSignKeyword_0_4; }
		
		//'<>'
		public Keyword getOpLessThanSignGreaterThanSignKeyword_0_5() { return cOpLessThanSignGreaterThanSignKeyword_0_5; }
		
		//'and'
		public Keyword getOpAndKeyword_0_6() { return cOpAndKeyword_0_6; }
		
		//'or'
		public Keyword getOpOrKeyword_0_7() { return cOpOrKeyword_0_7; }
		
		//'xor'
		public Keyword getOpXorKeyword_0_8() { return cOpXorKeyword_0_8; }
		
		//'implies'
		public Keyword getOpImpliesKeyword_0_9() { return cOpImpliesKeyword_0_9; }
	}
	public class MathOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.MathOperator");
		private final Assignment cOpAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cOpAlternatives_0 = (Alternatives)cOpAssignment.eContents().get(0);
		private final Keyword cOpAsteriskKeyword_0_0 = (Keyword)cOpAlternatives_0.eContents().get(0);
		private final Keyword cOpSolidusKeyword_0_1 = (Keyword)cOpAlternatives_0.eContents().get(1);
		private final Keyword cOpPlusSignKeyword_0_2 = (Keyword)cOpAlternatives_0.eContents().get(2);
		private final Keyword cOpHyphenMinusKeyword_0_3 = (Keyword)cOpAlternatives_0.eContents().get(3);
		
		//MathOperator returns MathOperator:
		//    op=('*' | '/' | '+' | '-');
		@Override public ParserRule getRule() { return rule; }
		
		//op=('*' | '/' | '+' | '-')
		public Assignment getOpAssignment() { return cOpAssignment; }
		
		//('*' | '/' | '+' | '-')
		public Alternatives getOpAlternatives_0() { return cOpAlternatives_0; }
		
		//'*'
		public Keyword getOpAsteriskKeyword_0_0() { return cOpAsteriskKeyword_0_0; }
		
		//'/'
		public Keyword getOpSolidusKeyword_0_1() { return cOpSolidusKeyword_0_1; }
		
		//'+'
		public Keyword getOpPlusSignKeyword_0_2() { return cOpPlusSignKeyword_0_2; }
		
		//'-'
		public Keyword getOpHyphenMinusKeyword_0_3() { return cOpHyphenMinusKeyword_0_3; }
	}
	public class NavigationOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.NavigationOperator");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cNameAlternatives_0 = (Alternatives)cNameAssignment.eContents().get(0);
		private final Keyword cNameFullStopKeyword_0_0 = (Keyword)cNameAlternatives_0.eContents().get(0);
		private final Keyword cNameHyphenMinusGreaterThanSignKeyword_0_1 = (Keyword)cNameAlternatives_0.eContents().get(1);
		
		//NavigationOperator:
		//    name=('.' | '->');
		@Override public ParserRule getRule() { return rule; }
		
		//name=('.' | '->')
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//('.' | '->')
		public Alternatives getNameAlternatives_0() { return cNameAlternatives_0; }
		
		//'.'
		public Keyword getNameFullStopKeyword_0_0() { return cNameFullStopKeyword_0_0; }
		
		//'->'
		public Keyword getNameHyphenMinusGreaterThanSignKeyword_0_1() { return cNameHyphenMinusGreaterThanSignKeyword_0_1; }
	}
	public class UnaryOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.UnaryOperator");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cNameAlternatives_0 = (Alternatives)cNameAssignment.eContents().get(0);
		private final Keyword cNameHyphenMinusKeyword_0_0 = (Keyword)cNameAlternatives_0.eContents().get(0);
		private final Keyword cNameNotKeyword_0_1 = (Keyword)cNameAlternatives_0.eContents().get(1);
		
		//UnaryOperator:
		//    name=('-' | 'not');
		@Override public ParserRule getRule() { return rule; }
		
		//name=('-' | 'not')
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//('-' | 'not')
		public Alternatives getNameAlternatives_0() { return cNameAlternatives_0; }
		
		//'-'
		public Keyword getNameHyphenMinusKeyword_0_0() { return cNameHyphenMinusKeyword_0_0; }
		
		//'not'
		public Keyword getNameNotKeyword_0_1() { return cNameNotKeyword_0_1; }
	}
	public class PrimaryExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.PrimaryExp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNestedExpParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cVarOrSelfExpParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Assignment cNavAssignment_1_1_0 = (Assignment)cGroup_1_1.eContents().get(0);
		private final RuleCall cNavNavigationOperatorParserRuleCall_1_1_0_0 = (RuleCall)cNavAssignment_1_1_0.eContents().get(0);
		private final Assignment cMethodsAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cMethodsMethodExpParserRuleCall_1_1_1_0 = (RuleCall)cMethodsAssignment_1_1_1.eContents().get(0);
		private final RuleCall cPrimitiveLiteralExpParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cTemporalExpParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//PrimaryExp returns Exp:
		//    NestedExp
		//|     VarOrSelfExp (nav+=NavigationOperator methods+=MethodExp)*
		////|     VarReference (nav+=NavigationOperator methods+=MethodExp)*
		//|     PrimitiveLiteralExp
		//|    TemporalExp
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//    NestedExp
		//|     VarOrSelfExp (nav+=NavigationOperator methods+=MethodExp)*
		////|     VarReference (nav+=NavigationOperator methods+=MethodExp)*
		//|     PrimitiveLiteralExp
		//|    TemporalExp
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//NestedExp
		public RuleCall getNestedExpParserRuleCall_0() { return cNestedExpParserRuleCall_0; }
		
		//VarOrSelfExp (nav+=NavigationOperator methods+=MethodExp)*
		public Group getGroup_1() { return cGroup_1; }
		
		//VarOrSelfExp
		public RuleCall getVarOrSelfExpParserRuleCall_1_0() { return cVarOrSelfExpParserRuleCall_1_0; }
		
		//(nav+=NavigationOperator methods+=MethodExp)*
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//nav+=NavigationOperator
		public Assignment getNavAssignment_1_1_0() { return cNavAssignment_1_1_0; }
		
		//NavigationOperator
		public RuleCall getNavNavigationOperatorParserRuleCall_1_1_0_0() { return cNavNavigationOperatorParserRuleCall_1_1_0_0; }
		
		//methods+=MethodExp
		public Assignment getMethodsAssignment_1_1_1() { return cMethodsAssignment_1_1_1; }
		
		//MethodExp
		public RuleCall getMethodsMethodExpParserRuleCall_1_1_1_0() { return cMethodsMethodExpParserRuleCall_1_1_1_0; }
		
		//PrimitiveLiteralExp
		public RuleCall getPrimitiveLiteralExpParserRuleCall_2() { return cPrimitiveLiteralExpParserRuleCall_2; }
		
		//TemporalExp
		public RuleCall getTemporalExpParserRuleCall_3() { return cTemporalExpParserRuleCall_3; }
	}
	public class NestedExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.NestedExp");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSourceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSourceExpParserRuleCall_1_0 = (RuleCall)cSourceAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//NestedExp returns NestedExp:
		//    '(' source=Exp ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' source=Exp ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//source=Exp
		public Assignment getSourceAssignment_1() { return cSourceAssignment_1; }
		
		//Exp
		public RuleCall getSourceExpParserRuleCall_1_0() { return cSourceExpParserRuleCall_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	public class VarOrSelfExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.VarOrSelfExp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSelfExpParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVarReferenceParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//VarOrSelfExp returns Exp:
		//    SelfExp | VarReference
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//SelfExp | VarReference
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//SelfExp
		public RuleCall getSelfExpParserRuleCall_0() { return cSelfExpParserRuleCall_0; }
		
		//VarReference
		public RuleCall getVarReferenceParserRuleCall_1() { return cVarReferenceParserRuleCall_1; }
	}
	public class SelfExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.SelfExp");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSelfExpAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cNameSelfKeyword_1_0 = (Keyword)cNameAssignment_1.eContents().get(0);
		
		//SelfExp:
		//    {SelfExp} name='self';
		@Override public ParserRule getRule() { return rule; }
		
		//{SelfExp} name='self'
		public Group getGroup() { return cGroup; }
		
		//{SelfExp}
		public Action getSelfExpAction_0() { return cSelfExpAction_0; }
		
		//name='self'
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//'self'
		public Keyword getNameSelfKeyword_1_0() { return cNameSelfKeyword_1_0; }
	}
	public class VarDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.VarDeclaration");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameSimpleNameParserRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//VarDeclaration:
		//    name=SimpleName
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name=SimpleName
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//SimpleName
		public RuleCall getNameSimpleNameParserRuleCall_0() { return cNameSimpleNameParserRuleCall_0; }
	}
	public class VarReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.VarReference");
		private final Assignment cRefAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cRefVarDeclarationCrossReference_0 = (CrossReference)cRefAssignment.eContents().get(0);
		private final RuleCall cRefVarDeclarationIDTerminalRuleCall_0_1 = (RuleCall)cRefVarDeclarationCrossReference_0.eContents().get(1);
		
		//VarReference: // variable reference
		//    ref=[VarDeclaration]
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//// variable reference
		//   ref=[VarDeclaration]
		public Assignment getRefAssignment() { return cRefAssignment; }
		
		//[VarDeclaration]
		public CrossReference getRefVarDeclarationCrossReference_0() { return cRefVarDeclarationCrossReference_0; }
		
		//ID
		public RuleCall getRefVarDeclarationIDTerminalRuleCall_0_1() { return cRefVarDeclarationIDTerminalRuleCall_0_1; }
	}
	public class PrimitiveLiteralExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.PrimitiveLiteralExp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNumberLiteralExpParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStringLiteralExpParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBooleanLiteralExpParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cNullLiteralExpParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//PrimitiveLiteralExp:
		//    NumberLiteralExp
		//    | StringLiteralExp
		//    | BooleanLiteralExp
		//    | NullLiteralExp
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//NumberLiteralExp
		//| StringLiteralExp
		//| BooleanLiteralExp
		//| NullLiteralExp
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//NumberLiteralExp
		public RuleCall getNumberLiteralExpParserRuleCall_0() { return cNumberLiteralExpParserRuleCall_0; }
		
		//StringLiteralExp
		public RuleCall getStringLiteralExpParserRuleCall_1() { return cStringLiteralExpParserRuleCall_1; }
		
		//BooleanLiteralExp
		public RuleCall getBooleanLiteralExpParserRuleCall_2() { return cBooleanLiteralExpParserRuleCall_2; }
		
		//NullLiteralExp
		public RuleCall getNullLiteralExpParserRuleCall_3() { return cNullLiteralExpParserRuleCall_3; }
	}
	public class NumberLiteralExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.NumberLiteralExp");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//NumberLiteralExp:
		//    value=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//value=INT
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//INT
		public RuleCall getValueINTTerminalRuleCall_0() { return cValueINTTerminalRuleCall_0; }
	}
	public class StringLiteralExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.StringLiteralExp");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//StringLiteralExp:
		//    value=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//value=STRING
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_0() { return cValueSTRINGTerminalRuleCall_0; }
	}
	public class BooleanLiteralExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.BooleanLiteralExp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cValueAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final Keyword cValueTrueKeyword_0_0 = (Keyword)cValueAssignment_0.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final Keyword cValueFalseKeyword_1_0 = (Keyword)cValueAssignment_1.eContents().get(0);
		
		//BooleanLiteralExp:
		//    value='true'
		//    | value='false';
		@Override public ParserRule getRule() { return rule; }
		
		//value='true'
		//| value='false'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//value='true'
		public Assignment getValueAssignment_0() { return cValueAssignment_0; }
		
		//'true'
		public Keyword getValueTrueKeyword_0_0() { return cValueTrueKeyword_0_0; }
		
		//value='false'
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//'false'
		public Keyword getValueFalseKeyword_1_0() { return cValueFalseKeyword_1_0; }
	}
	public class NullLiteralExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.NullLiteralExp");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNullLiteralExpCSAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cNullKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//NullLiteralExp:
		//    {NullLiteralExpCS} 'null';
		@Override public ParserRule getRule() { return rule; }
		
		//{NullLiteralExpCS} 'null'
		public Group getGroup() { return cGroup; }
		
		//{NullLiteralExpCS}
		public Action getNullLiteralExpCSAction_0() { return cNullLiteralExpCSAction_0; }
		
		//'null'
		public Keyword getNullKeyword_1() { return cNullKeyword_1; }
	}
	public class MethodExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.MethodExp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPropertyAccessParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMethodCallParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cCollectionIteratorParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cTypeCallParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//MethodExp:
		//     PropertyAccess
		//    | MethodCall
		////    | name=IteratorName '(' body=Exp ')'
		//    | CollectionIterator
		//    | TypeCall
		////    | iterSource=OperatorExp '->' iter=IteratorName '(' itervar=IteratorVarDeclaration ',' itervar2=IteratorVarDeclaration '|' body=OperatorExp ')'
		//    //| OperatorExp '->' IteratorName '(' IteratorVarDeclaration ';' InitVarDeclaration '|' OperatorExp ')'
		//    //| OperatorExp '->' IteratorName '(' InitVarDeclaration '|' OperatorExp ')'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//     PropertyAccess
		//    | MethodCall
		////    | name=IteratorName '(' body=Exp ')'
		//    | CollectionIterator
		//    | TypeCall
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PropertyAccess
		public RuleCall getPropertyAccessParserRuleCall_0() { return cPropertyAccessParserRuleCall_0; }
		
		//MethodCall
		public RuleCall getMethodCallParserRuleCall_1() { return cMethodCallParserRuleCall_1; }
		
		//CollectionIterator
		public RuleCall getCollectionIteratorParserRuleCall_2() { return cCollectionIteratorParserRuleCall_2; }
		
		//TypeCall
		public RuleCall getTypeCallParserRuleCall_3() { return cTypeCallParserRuleCall_3; }
	}
	public class CollectionIteratorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.CollectionIterator");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIteratorNameParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cItervarAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cItervarIteratorVarDeclarationParserRuleCall_2_0 = (RuleCall)cItervarAssignment_2.eContents().get(0);
		private final Keyword cVerticalLineKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBodyAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBodyExpParserRuleCall_4_0 = (RuleCall)cBodyAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//CollectionIterator returns IteratorExp:
		//    name=IteratorName '(' itervar=IteratorVarDeclaration '|' body=Exp ')'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name=IteratorName '(' itervar=IteratorVarDeclaration '|' body=Exp ')'
		public Group getGroup() { return cGroup; }
		
		//name=IteratorName
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IteratorName
		public RuleCall getNameIteratorNameParserRuleCall_0_0() { return cNameIteratorNameParserRuleCall_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//itervar=IteratorVarDeclaration
		public Assignment getItervarAssignment_2() { return cItervarAssignment_2; }
		
		//IteratorVarDeclaration
		public RuleCall getItervarIteratorVarDeclarationParserRuleCall_2_0() { return cItervarIteratorVarDeclarationParserRuleCall_2_0; }
		
		//'|'
		public Keyword getVerticalLineKeyword_3() { return cVerticalLineKeyword_3; }
		
		//body=Exp
		public Assignment getBodyAssignment_4() { return cBodyAssignment_4; }
		
		//Exp
		public RuleCall getBodyExpParserRuleCall_4_0() { return cBodyExpParserRuleCall_4_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class IteratorNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.IteratorName");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cNameAlternatives_0 = (Alternatives)cNameAssignment.eContents().get(0);
		private final Keyword cNameForAllKeyword_0_0 = (Keyword)cNameAlternatives_0.eContents().get(0);
		private final Keyword cNameExistsKeyword_0_1 = (Keyword)cNameAlternatives_0.eContents().get(1);
		private final Keyword cNameCollectKeyword_0_2 = (Keyword)cNameAlternatives_0.eContents().get(2);
		private final Keyword cNameRejectKeyword_0_3 = (Keyword)cNameAlternatives_0.eContents().get(3);
		private final Keyword cNameSelectKeyword_0_4 = (Keyword)cNameAlternatives_0.eContents().get(4);
		
		//IteratorName:
		//    name=('forAll'|'exists'|'collect'|'reject'|'select');
		@Override public ParserRule getRule() { return rule; }
		
		//name=('forAll'|'exists'|'collect'|'reject'|'select')
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//('forAll'|'exists'|'collect'|'reject'|'select')
		public Alternatives getNameAlternatives_0() { return cNameAlternatives_0; }
		
		//'forAll'
		public Keyword getNameForAllKeyword_0_0() { return cNameForAllKeyword_0_0; }
		
		//'exists'
		public Keyword getNameExistsKeyword_0_1() { return cNameExistsKeyword_0_1; }
		
		//'collect'
		public Keyword getNameCollectKeyword_0_2() { return cNameCollectKeyword_0_2; }
		
		//'reject'
		public Keyword getNameRejectKeyword_0_3() { return cNameRejectKeyword_0_3; }
		
		//'select'
		public Keyword getNameSelectKeyword_0_4() { return cNameSelectKeyword_0_4; }
	}
	public class IteratorVarDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.IteratorVarDeclaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cNameVarDeclarationParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cNameAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cNameVarDeclarationParserRuleCall_1_0_0 = (RuleCall)cNameAssignment_1_0.eContents().get(0);
		private final Keyword cColonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cTypeAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cTypeTypeExpParserRuleCall_1_2_0 = (RuleCall)cTypeAssignment_1_2.eContents().get(0);
		
		//IteratorVarDeclaration:
		//    name=VarDeclaration | name=VarDeclaration ':' type=TypeExp;
		@Override public ParserRule getRule() { return rule; }
		
		//name=VarDeclaration | name=VarDeclaration ':' type=TypeExp
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//name=VarDeclaration
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//VarDeclaration
		public RuleCall getNameVarDeclarationParserRuleCall_0_0() { return cNameVarDeclarationParserRuleCall_0_0; }
		
		//name=VarDeclaration ':' type=TypeExp
		public Group getGroup_1() { return cGroup_1; }
		
		//name=VarDeclaration
		public Assignment getNameAssignment_1_0() { return cNameAssignment_1_0; }
		
		//VarDeclaration
		public RuleCall getNameVarDeclarationParserRuleCall_1_0_0() { return cNameVarDeclarationParserRuleCall_1_0_0; }
		
		//':'
		public Keyword getColonKeyword_1_1() { return cColonKeyword_1_1; }
		
		//type=TypeExp
		public Assignment getTypeAssignment_1_2() { return cTypeAssignment_1_2; }
		
		//TypeExp
		public RuleCall getTypeTypeExpParserRuleCall_1_2_0() { return cTypeTypeExpParserRuleCall_1_2_0; }
	}
	public class PropertyAccessElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.PropertyAccess");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameSimpleNameParserRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//PropertyAccess returns PropertyAccessExp:
		//    name=SimpleName
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name=SimpleName
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//SimpleName
		public RuleCall getNameSimpleNameParserRuleCall_0() { return cNameSimpleNameParserRuleCall_0; }
	}
	public class MethodCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.MethodCall");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cNameAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cNameSimpleNameParserRuleCall_0_0_0 = (RuleCall)cNameAssignment_0_0.eContents().get(0);
		private final Keyword cLeftParenthesisRightParenthesisKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cNameAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cNameSimpleNameParserRuleCall_1_0_0 = (RuleCall)cNameAssignment_1_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cArgsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cArgsArgumentsExpParserRuleCall_1_2_0 = (RuleCall)cArgsAssignment_1_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//MethodCall returns MethodCallExp:
		//    name=SimpleName '()'         // operation call
		//    | name=SimpleName '('args=ArgumentsExp')' // operation call
		////    | name=SimpleName '('type=TypeExp')'    // type operation call
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name=SimpleName '()'         // operation call
		//| name=SimpleName '('args=ArgumentsExp')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//name=SimpleName '()'
		public Group getGroup_0() { return cGroup_0; }
		
		//name=SimpleName
		public Assignment getNameAssignment_0_0() { return cNameAssignment_0_0; }
		
		//SimpleName
		public RuleCall getNameSimpleNameParserRuleCall_0_0_0() { return cNameSimpleNameParserRuleCall_0_0_0; }
		
		//'()'
		public Keyword getLeftParenthesisRightParenthesisKeyword_0_1() { return cLeftParenthesisRightParenthesisKeyword_0_1; }
		
		//name=SimpleName '('args=ArgumentsExp')'
		public Group getGroup_1() { return cGroup_1; }
		
		//name=SimpleName
		public Assignment getNameAssignment_1_0() { return cNameAssignment_1_0; }
		
		//SimpleName
		public RuleCall getNameSimpleNameParserRuleCall_1_0_0() { return cNameSimpleNameParserRuleCall_1_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }
		
		//args=ArgumentsExp
		public Assignment getArgsAssignment_1_2() { return cArgsAssignment_1_2; }
		
		//ArgumentsExp
		public RuleCall getArgsArgumentsExpParserRuleCall_1_2_0() { return cArgsArgumentsExpParserRuleCall_1_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
	}
	public class TypeCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.TypeCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cNameAlternatives_0_0 = (Alternatives)cNameAssignment_0.eContents().get(0);
		private final Keyword cNameAsTypeKeyword_0_0_0 = (Keyword)cNameAlternatives_0_0.eContents().get(0);
		private final Keyword cNameIsTypeOfKeyword_0_0_1 = (Keyword)cNameAlternatives_0_0.eContents().get(1);
		private final Keyword cNameIsKindOfKeyword_0_0_2 = (Keyword)cNameAlternatives_0_0.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeExpParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//TypeCall returns TypeCallExp:
		//    name=('asType'|'isTypeOf'|'isKindOf')'('type=TypeExp')'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name=('asType'|'isTypeOf'|'isKindOf')'('type=TypeExp')'
		public Group getGroup() { return cGroup; }
		
		//name=('asType'|'isTypeOf'|'isKindOf')
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//('asType'|'isTypeOf'|'isKindOf')
		public Alternatives getNameAlternatives_0_0() { return cNameAlternatives_0_0; }
		
		//'asType'
		public Keyword getNameAsTypeKeyword_0_0_0() { return cNameAsTypeKeyword_0_0_0; }
		
		//'isTypeOf'
		public Keyword getNameIsTypeOfKeyword_0_0_1() { return cNameIsTypeOfKeyword_0_0_1; }
		
		//'isKindOf'
		public Keyword getNameIsKindOfKeyword_0_0_2() { return cNameIsKindOfKeyword_0_0_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//type=TypeExp
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//TypeExp
		public RuleCall getTypeTypeExpParserRuleCall_2_0() { return cTypeTypeExpParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class TypeExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.TypeExp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cTypeExpAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cLessThanSignKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cNameAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cNamePathParserRuleCall_0_2_0 = (RuleCall)cNameAssignment_0_2.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_0_3 = (Keyword)cGroup_0.eContents().get(3);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cCollectionTypeAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cCollectionTypeCollectionTypeIdentifierParserRuleCall_1_0_0 = (RuleCall)cCollectionTypeAssignment_1_0.eContents().get(0);
		private final Assignment cTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypeTypeExpParserRuleCall_1_1_0 = (RuleCall)cTypeAssignment_1_1.eContents().get(0);
		
		//TypeExp :
		//     {TypeExp} '<' name=Path '>' // eventually we want to replace this with . notated FQN
		//    | collectionType=CollectionTypeIdentifier type=TypeExp;
		@Override public ParserRule getRule() { return rule; }
		
		// {TypeExp} '<' name=Path '>' // eventually we want to replace this with . notated FQN
		//| collectionType=CollectionTypeIdentifier type=TypeExp
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{TypeExp} '<' name=Path '>'
		public Group getGroup_0() { return cGroup_0; }
		
		//{TypeExp}
		public Action getTypeExpAction_0_0() { return cTypeExpAction_0_0; }
		
		//'<'
		public Keyword getLessThanSignKeyword_0_1() { return cLessThanSignKeyword_0_1; }
		
		//name=Path
		public Assignment getNameAssignment_0_2() { return cNameAssignment_0_2; }
		
		//Path
		public RuleCall getNamePathParserRuleCall_0_2_0() { return cNamePathParserRuleCall_0_2_0; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_0_3() { return cGreaterThanSignKeyword_0_3; }
		
		//collectionType=CollectionTypeIdentifier type=TypeExp
		public Group getGroup_1() { return cGroup_1; }
		
		//collectionType=CollectionTypeIdentifier
		public Assignment getCollectionTypeAssignment_1_0() { return cCollectionTypeAssignment_1_0; }
		
		//CollectionTypeIdentifier
		public RuleCall getCollectionTypeCollectionTypeIdentifierParserRuleCall_1_0_0() { return cCollectionTypeCollectionTypeIdentifierParserRuleCall_1_0_0; }
		
		//type=TypeExp
		public Assignment getTypeAssignment_1_1() { return cTypeAssignment_1_1; }
		
		//TypeExp
		public RuleCall getTypeTypeExpParserRuleCall_1_1_0() { return cTypeTypeExpParserRuleCall_1_1_0; }
	}
	public class CollectionTypeIdentifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.CollectionTypeIdentifier");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cNameAlternatives_0 = (Alternatives)cNameAssignment.eContents().get(0);
		private final Keyword cNameSetKeyword_0_0 = (Keyword)cNameAlternatives_0.eContents().get(0);
		private final Keyword cNameListKeyword_0_1 = (Keyword)cNameAlternatives_0.eContents().get(1);
		private final Keyword cNameMapKeyword_0_2 = (Keyword)cNameAlternatives_0.eContents().get(2);
		private final Keyword cNameCollectionKeyword_0_3 = (Keyword)cNameAlternatives_0.eContents().get(3);
		
		//CollectionTypeIdentifier: // not really used yet, as only needed to define literals
		//    name=('set'|'list'|'map'|'collection')
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//// not really used yet, as only needed to define literals
		//   name=('set'|'list'|'map'|'collection')
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//('set'|'list'|'map'|'collection')
		public Alternatives getNameAlternatives_0() { return cNameAlternatives_0; }
		
		//'set'
		public Keyword getNameSetKeyword_0_0() { return cNameSetKeyword_0_0; }
		
		//'list'
		public Keyword getNameListKeyword_0_1() { return cNameListKeyword_0_1; }
		
		//'map'
		public Keyword getNameMapKeyword_0_2() { return cNameMapKeyword_0_2; }
		
		//'collection'
		public Keyword getNameCollectionKeyword_0_3() { return cNameCollectionKeyword_0_3; }
	}
	public class TemporalExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.TemporalExp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUnaryTemporalExpParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTriggeredTemporalExpParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//TemporalExp returns TemporalExp:
		//    UnaryTemporalExp | TriggeredTemporalExp
		//    //| DeclarePatternExp
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//UnaryTemporalExp | TriggeredTemporalExp
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//UnaryTemporalExp
		public RuleCall getUnaryTemporalExpParserRuleCall_0() { return cUnaryTemporalExpParserRuleCall_0; }
		
		//TriggeredTemporalExp
		public RuleCall getTriggeredTemporalExpParserRuleCall_1() { return cTriggeredTemporalExpParserRuleCall_1; }
	}
	public class UnaryTemporalExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.UnaryTemporalExp");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameUnaryTemporalOpParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpExpParserRuleCall_2_0 = (RuleCall)cExpAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//UnaryTemporalExp:
		//    name=UnaryTemporalOp '(' exp=Exp ')'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name=UnaryTemporalOp '(' exp=Exp ')'
		public Group getGroup() { return cGroup; }
		
		//name=UnaryTemporalOp
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//UnaryTemporalOp
		public RuleCall getNameUnaryTemporalOpParserRuleCall_0_0() { return cNameUnaryTemporalOpParserRuleCall_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//exp=Exp
		public Assignment getExpAssignment_2() { return cExpAssignment_2; }
		
		//Exp
		public RuleCall getExpExpParserRuleCall_2_0() { return cExpExpParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class UnaryTemporalOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.UnaryTemporalOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cNextKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cAlwaysKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cEventuallyKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//UnaryTemporalOp:
		//    'next' | 'always' | 'eventually'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'next' | 'always' | 'eventually'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'next'
		public Keyword getNextKeyword_0() { return cNextKeyword_0; }
		
		//'always'
		public Keyword getAlwaysKeyword_1() { return cAlwaysKeyword_1; }
		
		//'eventually'
		public Keyword getEventuallyKeyword_2() { return cEventuallyKeyword_2; }
	}
	public class TriggeredTemporalExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.TriggeredTemporalExp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTemporalAsLongAsParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTemporalUntilParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cTemporalEverytimeParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cTemporalAtLeastOnceParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cLegacyUntilParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cLegacyAsSoonAsParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cLegacyEverytimeParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		
		//TriggeredTemporalExp returns TriggeredTemporalExp:
		//    TemporalAsLongAs | TemporalUntil | TemporalEverytime | TemporalAtLeastOnce
		//    | LegacyUntil | LegacyAsSoonAs | LegacyEverytime
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//TemporalAsLongAs | TemporalUntil | TemporalEverytime | TemporalAtLeastOnce
		//| LegacyUntil | LegacyAsSoonAs | LegacyEverytime
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//TemporalAsLongAs
		public RuleCall getTemporalAsLongAsParserRuleCall_0() { return cTemporalAsLongAsParserRuleCall_0; }
		
		//TemporalUntil
		public RuleCall getTemporalUntilParserRuleCall_1() { return cTemporalUntilParserRuleCall_1; }
		
		//TemporalEverytime
		public RuleCall getTemporalEverytimeParserRuleCall_2() { return cTemporalEverytimeParserRuleCall_2; }
		
		//TemporalAtLeastOnce
		public RuleCall getTemporalAtLeastOnceParserRuleCall_3() { return cTemporalAtLeastOnceParserRuleCall_3; }
		
		//LegacyUntil
		public RuleCall getLegacyUntilParserRuleCall_4() { return cLegacyUntilParserRuleCall_4; }
		
		//LegacyAsSoonAs
		public RuleCall getLegacyAsSoonAsParserRuleCall_5() { return cLegacyAsSoonAsParserRuleCall_5; }
		
		//LegacyEverytime
		public RuleCall getLegacyEverytimeParserRuleCall_6() { return cLegacyEverytimeParserRuleCall_6; }
	}
	public class TemporalAsLongAsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.TemporalAsLongAs");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameAsLongAsKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cBAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBExpParserRuleCall_2_0 = (RuleCall)cBAssignment_2.eContents().get(0);
		private final Keyword cEnsureThatKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cAAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cAExpParserRuleCall_4_0 = (RuleCall)cAAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		///* Alternative Until, interpret: asLongAs(A) ensureThat(B) => as long as A is true, ensure that B is true , A must become true at some time in the future */
		//TemporalAsLongAs returns TriggeredTemporalExp:
		//    name='asLongAs' '(' b=Exp 'ensureThat' a=Exp ')'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name='asLongAs' '(' b=Exp 'ensureThat' a=Exp ')'
		public Group getGroup() { return cGroup; }
		
		//name='asLongAs'
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//'asLongAs'
		public Keyword getNameAsLongAsKeyword_0_0() { return cNameAsLongAsKeyword_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//b=Exp
		public Assignment getBAssignment_2() { return cBAssignment_2; }
		
		//Exp
		public RuleCall getBExpParserRuleCall_2_0() { return cBExpParserRuleCall_2_0; }
		
		//'ensureThat'
		public Keyword getEnsureThatKeyword_3() { return cEnsureThatKeyword_3; }
		
		//a=Exp
		public Assignment getAAssignment_4() { return cAAssignment_4; }
		
		//Exp
		public RuleCall getAExpParserRuleCall_4_0() { return cAExpParserRuleCall_4_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class TemporalUntilElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.TemporalUntil");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameEnsureThatKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cAAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAExpParserRuleCall_2_0 = (RuleCall)cAAssignment_2.eContents().get(0);
		private final Keyword cAsLongAsKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBExpParserRuleCall_4_0 = (RuleCall)cBAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		///* Regular Until, interpret: ensureThat(B) asLongAs(A)  => ensure that A is true as long as B is true , B must become true at some time in the future */
		//TemporalUntil returns TriggeredTemporalExp:
		//    name='ensureThat' '(' a=Exp 'asLongAs'  b=Exp ')'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name='ensureThat' '(' a=Exp 'asLongAs'  b=Exp ')'
		public Group getGroup() { return cGroup; }
		
		//name='ensureThat'
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//'ensureThat'
		public Keyword getNameEnsureThatKeyword_0_0() { return cNameEnsureThatKeyword_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//a=Exp
		public Assignment getAAssignment_2() { return cAAssignment_2; }
		
		//Exp
		public RuleCall getAExpParserRuleCall_2_0() { return cAExpParserRuleCall_2_0; }
		
		//'asLongAs'
		public Keyword getAsLongAsKeyword_3() { return cAsLongAsKeyword_3; }
		
		//b=Exp
		public Assignment getBAssignment_4() { return cBAssignment_4; }
		
		//Exp
		public RuleCall getBExpParserRuleCall_4_0() { return cBExpParserRuleCall_4_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class TemporalEverytimeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.TemporalEverytime");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameEveryTimeKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cAAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAExpParserRuleCall_2_0 = (RuleCall)cAAssignment_2.eContents().get(0);
		private final Keyword cThenKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBExpParserRuleCall_4_0 = (RuleCall)cBAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//TemporalEverytime returns TriggeredTemporalExp:
		//    name='everyTime' '(' a=Exp 'then'  b=Exp ')'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name='everyTime' '(' a=Exp 'then'  b=Exp ')'
		public Group getGroup() { return cGroup; }
		
		//name='everyTime'
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//'everyTime'
		public Keyword getNameEveryTimeKeyword_0_0() { return cNameEveryTimeKeyword_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//a=Exp
		public Assignment getAAssignment_2() { return cAAssignment_2; }
		
		//Exp
		public RuleCall getAExpParserRuleCall_2_0() { return cAExpParserRuleCall_2_0; }
		
		//'then'
		public Keyword getThenKeyword_3() { return cThenKeyword_3; }
		
		//b=Exp
		public Assignment getBAssignment_4() { return cBAssignment_4; }
		
		//Exp
		public RuleCall getBExpParserRuleCall_4_0() { return cBExpParserRuleCall_4_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class TemporalAtLeastOnceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.TemporalAtLeastOnce");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameWhenOnceKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cAAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAExpParserRuleCall_2_0 = (RuleCall)cAAssignment_2.eContents().get(0);
		private final Keyword cThenAtLeastOnceKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBExpParserRuleCall_4_0 = (RuleCall)cBAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//TemporalAtLeastOnce returns TriggeredTemporalExp:
		//    name='whenOnce' '(' a=Exp  'thenAtLeastOnce'  b=Exp ')'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name='whenOnce' '(' a=Exp  'thenAtLeastOnce'  b=Exp ')'
		public Group getGroup() { return cGroup; }
		
		//name='whenOnce'
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//'whenOnce'
		public Keyword getNameWhenOnceKeyword_0_0() { return cNameWhenOnceKeyword_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//a=Exp
		public Assignment getAAssignment_2() { return cAAssignment_2; }
		
		//Exp
		public RuleCall getAExpParserRuleCall_2_0() { return cAExpParserRuleCall_2_0; }
		
		//'thenAtLeastOnce'
		public Keyword getThenAtLeastOnceKeyword_3() { return cThenAtLeastOnceKeyword_3; }
		
		//b=Exp
		public Assignment getBAssignment_4() { return cBAssignment_4; }
		
		//Exp
		public RuleCall getBExpParserRuleCall_4_0() { return cBExpParserRuleCall_4_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class LegacyUntilElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.LegacyUntil");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameUntilKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cAAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAExpParserRuleCall_2_0 = (RuleCall)cAAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBExpParserRuleCall_4_0 = (RuleCall)cBAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//LegacyUntil returns TriggeredTemporalExp:
		//    name='until' '('a=Exp ',' b=Exp')'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name='until' '('a=Exp ',' b=Exp')'
		public Group getGroup() { return cGroup; }
		
		//name='until'
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//'until'
		public Keyword getNameUntilKeyword_0_0() { return cNameUntilKeyword_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//a=Exp
		public Assignment getAAssignment_2() { return cAAssignment_2; }
		
		//Exp
		public RuleCall getAExpParserRuleCall_2_0() { return cAExpParserRuleCall_2_0; }
		
		//','
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//b=Exp
		public Assignment getBAssignment_4() { return cBAssignment_4; }
		
		//Exp
		public RuleCall getBExpParserRuleCall_4_0() { return cBExpParserRuleCall_4_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class LegacyAsSoonAsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.LegacyAsSoonAs");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameAsSoonAsKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cAAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAExpParserRuleCall_2_0 = (RuleCall)cAAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBExpParserRuleCall_4_0 = (RuleCall)cBAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//LegacyAsSoonAs returns TriggeredTemporalExp:
		//    name='asSoonAs' '('a=Exp ',' b=Exp')'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name='asSoonAs' '('a=Exp ',' b=Exp')'
		public Group getGroup() { return cGroup; }
		
		//name='asSoonAs'
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//'asSoonAs'
		public Keyword getNameAsSoonAsKeyword_0_0() { return cNameAsSoonAsKeyword_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//a=Exp
		public Assignment getAAssignment_2() { return cAAssignment_2; }
		
		//Exp
		public RuleCall getAExpParserRuleCall_2_0() { return cAExpParserRuleCall_2_0; }
		
		//','
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//b=Exp
		public Assignment getBAssignment_4() { return cBAssignment_4; }
		
		//Exp
		public RuleCall getBExpParserRuleCall_4_0() { return cBExpParserRuleCall_4_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class LegacyEverytimeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.LegacyEverytime");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameEverytimeKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cAAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAExpParserRuleCall_2_0 = (RuleCall)cAAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBExpParserRuleCall_4_0 = (RuleCall)cBAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//LegacyEverytime returns TriggeredTemporalExp:
		//    name='everytime' '('a=Exp ',' b=Exp')'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name='everytime' '('a=Exp ',' b=Exp')'
		public Group getGroup() { return cGroup; }
		
		//name='everytime'
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//'everytime'
		public Keyword getNameEverytimeKeyword_0_0() { return cNameEverytimeKeyword_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//a=Exp
		public Assignment getAAssignment_2() { return cAAssignment_2; }
		
		//Exp
		public RuleCall getAExpParserRuleCall_2_0() { return cAExpParserRuleCall_2_0; }
		
		//','
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//b=Exp
		public Assignment getBAssignment_4() { return cBAssignment_4; }
		
		//Exp
		public RuleCall getBExpParserRuleCall_4_0() { return cBExpParserRuleCall_4_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class PathElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.Path");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSimpleNameParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cSolidusKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cSimpleNameParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		////DeclarePatternExp:
		////    'atMostOnce' |
		////    'bothOrNeither' | // coexistence
		////    'whenever' 'eventually' | // response
		////
		////
		////;
		//Path:
		//     SimpleName ( '/'  SimpleName)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//SimpleName ( '/'  SimpleName)*
		public Group getGroup() { return cGroup; }
		
		//SimpleName
		public RuleCall getSimpleNameParserRuleCall_0() { return cSimpleNameParserRuleCall_0; }
		
		//( '/'  SimpleName)*
		public Group getGroup_1() { return cGroup_1; }
		
		//'/'
		public Keyword getSolidusKeyword_1_0() { return cSolidusKeyword_1_0; }
		
		//SimpleName
		public RuleCall getSimpleNameParserRuleCall_1_1() { return cSimpleNameParserRuleCall_1_1; }
	}
	public class ArgumentsExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.ArgumentsExp");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOperatorsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOperatorsExpParserRuleCall_0_0 = (RuleCall)cOperatorsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cOperatorsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorsExpParserRuleCall_1_1_0 = (RuleCall)cOperatorsAssignment_1_1.eContents().get(0);
		
		//ArgumentsExp:
		//    operators+=Exp (',' operators+=Exp)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//operators+=Exp (',' operators+=Exp)*
		public Group getGroup() { return cGroup; }
		
		//operators+=Exp
		public Assignment getOperatorsAssignment_0() { return cOperatorsAssignment_0; }
		
		//Exp
		public RuleCall getOperatorsExpParserRuleCall_0_0() { return cOperatorsExpParserRuleCall_0_0; }
		
		//(',' operators+=Exp)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//operators+=Exp
		public Assignment getOperatorsAssignment_1_1() { return cOperatorsAssignment_1_1; }
		
		//Exp
		public RuleCall getOperatorsExpParserRuleCall_1_1_0() { return cOperatorsExpParserRuleCall_1_1_0; }
	}
	
	
	private final ModelElements pModel;
	private final ConstraintElements pConstraint;
	private final QualifiedNameElements pQualifiedName;
	private final SimpleNameElements pSimpleName;
	private final TerminalRule tDESCRIPTION;
	private final ContextElements pContext;
	private final ExpElements pExp;
	private final PrefixedExpElements pPrefixedExp;
	private final BinaryOperatorElements pBinaryOperator;
	private final InfixOperatorElements pInfixOperator;
	private final BooleanOperatorElements pBooleanOperator;
	private final MathOperatorElements pMathOperator;
	private final NavigationOperatorElements pNavigationOperator;
	private final UnaryOperatorElements pUnaryOperator;
	private final PrimaryExpElements pPrimaryExp;
	private final NestedExpElements pNestedExp;
	private final VarOrSelfExpElements pVarOrSelfExp;
	private final SelfExpElements pSelfExp;
	private final VarDeclarationElements pVarDeclaration;
	private final VarReferenceElements pVarReference;
	private final PrimitiveLiteralExpElements pPrimitiveLiteralExp;
	private final NumberLiteralExpElements pNumberLiteralExp;
	private final StringLiteralExpElements pStringLiteralExp;
	private final BooleanLiteralExpElements pBooleanLiteralExp;
	private final NullLiteralExpElements pNullLiteralExp;
	private final MethodExpElements pMethodExp;
	private final CollectionIteratorElements pCollectionIterator;
	private final IteratorNameElements pIteratorName;
	private final IteratorVarDeclarationElements pIteratorVarDeclaration;
	private final PropertyAccessElements pPropertyAccess;
	private final MethodCallElements pMethodCall;
	private final TypeCallElements pTypeCall;
	private final TypeExpElements pTypeExp;
	private final CollectionTypeIdentifierElements pCollectionTypeIdentifier;
	private final TemporalExpElements pTemporalExp;
	private final UnaryTemporalExpElements pUnaryTemporalExp;
	private final UnaryTemporalOpElements pUnaryTemporalOp;
	private final TriggeredTemporalExpElements pTriggeredTemporalExp;
	private final TemporalAsLongAsElements pTemporalAsLongAs;
	private final TemporalUntilElements pTemporalUntil;
	private final TemporalEverytimeElements pTemporalEverytime;
	private final TemporalAtLeastOnceElements pTemporalAtLeastOnce;
	private final LegacyUntilElements pLegacyUntil;
	private final LegacyAsSoonAsElements pLegacyAsSoonAs;
	private final LegacyEverytimeElements pLegacyEverytime;
	private final PathElements pPath;
	private final ArgumentsExpElements pArgumentsExp;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public OCLXGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pModel = new ModelElements();
		this.pConstraint = new ConstraintElements();
		this.pQualifiedName = new QualifiedNameElements();
		this.pSimpleName = new SimpleNameElements();
		this.tDESCRIPTION = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "at.jku.isse.OCLX.DESCRIPTION");
		this.pContext = new ContextElements();
		this.pExp = new ExpElements();
		this.pPrefixedExp = new PrefixedExpElements();
		this.pBinaryOperator = new BinaryOperatorElements();
		this.pInfixOperator = new InfixOperatorElements();
		this.pBooleanOperator = new BooleanOperatorElements();
		this.pMathOperator = new MathOperatorElements();
		this.pNavigationOperator = new NavigationOperatorElements();
		this.pUnaryOperator = new UnaryOperatorElements();
		this.pPrimaryExp = new PrimaryExpElements();
		this.pNestedExp = new NestedExpElements();
		this.pVarOrSelfExp = new VarOrSelfExpElements();
		this.pSelfExp = new SelfExpElements();
		this.pVarDeclaration = new VarDeclarationElements();
		this.pVarReference = new VarReferenceElements();
		this.pPrimitiveLiteralExp = new PrimitiveLiteralExpElements();
		this.pNumberLiteralExp = new NumberLiteralExpElements();
		this.pStringLiteralExp = new StringLiteralExpElements();
		this.pBooleanLiteralExp = new BooleanLiteralExpElements();
		this.pNullLiteralExp = new NullLiteralExpElements();
		this.pMethodExp = new MethodExpElements();
		this.pCollectionIterator = new CollectionIteratorElements();
		this.pIteratorName = new IteratorNameElements();
		this.pIteratorVarDeclaration = new IteratorVarDeclarationElements();
		this.pPropertyAccess = new PropertyAccessElements();
		this.pMethodCall = new MethodCallElements();
		this.pTypeCall = new TypeCallElements();
		this.pTypeExp = new TypeExpElements();
		this.pCollectionTypeIdentifier = new CollectionTypeIdentifierElements();
		this.pTemporalExp = new TemporalExpElements();
		this.pUnaryTemporalExp = new UnaryTemporalExpElements();
		this.pUnaryTemporalOp = new UnaryTemporalOpElements();
		this.pTriggeredTemporalExp = new TriggeredTemporalExpElements();
		this.pTemporalAsLongAs = new TemporalAsLongAsElements();
		this.pTemporalUntil = new TemporalUntilElements();
		this.pTemporalEverytime = new TemporalEverytimeElements();
		this.pTemporalAtLeastOnce = new TemporalAtLeastOnceElements();
		this.pLegacyUntil = new LegacyUntilElements();
		this.pLegacyAsSoonAs = new LegacyAsSoonAsElements();
		this.pLegacyEverytime = new LegacyEverytimeElements();
		this.pPath = new PathElements();
		this.pArgumentsExp = new ArgumentsExpElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("at.jku.isse.OCLX".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model:
	//    constraints+=Constraint*;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	//Constraint:
	//    'rule' name=ID '{'
	//        ('description:'  description=DESCRIPTION )?
	//        ('is' 'overrulable:' overrulable?=BooleanLiteralExp)?
	//        'context:' context=Context
	//        'expression:' expression=Exp
	//    "}";
	public ConstraintElements getConstraintAccess() {
		return pConstraint;
	}
	
	public ParserRule getConstraintRule() {
		return getConstraintAccess().getRule();
	}
	
	//QualifiedName:
	//    ID ('.' ID)*;
	public QualifiedNameElements getQualifiedNameAccess() {
		return pQualifiedName;
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}
	
	//SimpleName:
	//    ID;
	public SimpleNameElements getSimpleNameAccess() {
		return pSimpleName;
	}
	
	public ParserRule getSimpleNameRule() {
		return getSimpleNameAccess().getRule();
	}
	
	//terminal DESCRIPTION:
	//    '\"' -> '\"'
	//;
	public TerminalRule getDESCRIPTIONRule() {
		return tDESCRIPTION;
	}
	
	//Context:
	//    name = QualifiedName
	//;
	public ContextElements getContextAccess() {
		return pContext;
	}
	
	public ParserRule getContextRule() {
		return getContextAccess().getRule();
	}
	
	//Exp returns Exp: //if there are more expressions, make sure that the initial PrefixedExp in the following line is added to the list of expressions via 'current'
	//    PrefixedExp (
	//        {InfixExp.expressions+=current} operators+=BinaryOperator expressions+=PrefixedExp
	//        (operators+=BinaryOperator expressions+=PrefixedExp)*
	//    )?;
	public ExpElements getExpAccess() {
		return pExp;
	}
	
	public ParserRule getExpRule() {
		return getExpAccess().getRule();
	}
	
	///*
	// * Expression can start with a varref (that might be prefixed with a 'not' or '-' )
	// *
	// */
	//PrefixedExp returns Exp:
	//    ({PrefixExp} operator=UnaryOperator expression=PrimaryExp)
	//    |     PrimaryExp
	//;
	public PrefixedExpElements getPrefixedExpAccess() {
		return pPrefixedExp;
	}
	
	public ParserRule getPrefixedExpRule() {
		return getPrefixedExpAccess().getRule();
	}
	
	//BinaryOperator returns BinaryOperator: // we need to split these, as after a navigation we can no longer use a var ref, while we cannot use a property access upon an infix operator
	//    InfixOperator // | NavigationOperator
	//;
	public BinaryOperatorElements getBinaryOperatorAccess() {
		return pBinaryOperator;
	}
	
	public ParserRule getBinaryOperatorRule() {
		return getBinaryOperatorAccess().getRule();
	}
	
	//InfixOperator returns BinaryOperator:
	//    BooleanOperator | MathOperator;
	public InfixOperatorElements getInfixOperatorAccess() {
		return pInfixOperator;
	}
	
	public ParserRule getInfixOperatorRule() {
		return getInfixOperatorAccess().getRule();
	}
	
	//BooleanOperator returns BooleanOperator:
	//    op=('>' | '<' | '>=' | '<=' | '=' | '<>' | 'and' | 'or' | 'xor' | 'implies');
	public BooleanOperatorElements getBooleanOperatorAccess() {
		return pBooleanOperator;
	}
	
	public ParserRule getBooleanOperatorRule() {
		return getBooleanOperatorAccess().getRule();
	}
	
	//MathOperator returns MathOperator:
	//    op=('*' | '/' | '+' | '-');
	public MathOperatorElements getMathOperatorAccess() {
		return pMathOperator;
	}
	
	public ParserRule getMathOperatorRule() {
		return getMathOperatorAccess().getRule();
	}
	
	//NavigationOperator:
	//    name=('.' | '->');
	public NavigationOperatorElements getNavigationOperatorAccess() {
		return pNavigationOperator;
	}
	
	public ParserRule getNavigationOperatorRule() {
		return getNavigationOperatorAccess().getRule();
	}
	
	//UnaryOperator:
	//    name=('-' | 'not');
	public UnaryOperatorElements getUnaryOperatorAccess() {
		return pUnaryOperator;
	}
	
	public ParserRule getUnaryOperatorRule() {
		return getUnaryOperatorAccess().getRule();
	}
	
	//PrimaryExp returns Exp:
	//    NestedExp
	//|     VarOrSelfExp (nav+=NavigationOperator methods+=MethodExp)*
	////|     VarReference (nav+=NavigationOperator methods+=MethodExp)*
	//|     PrimitiveLiteralExp
	//|    TemporalExp
	//;
	public PrimaryExpElements getPrimaryExpAccess() {
		return pPrimaryExp;
	}
	
	public ParserRule getPrimaryExpRule() {
		return getPrimaryExpAccess().getRule();
	}
	
	//NestedExp returns NestedExp:
	//    '(' source=Exp ')';
	public NestedExpElements getNestedExpAccess() {
		return pNestedExp;
	}
	
	public ParserRule getNestedExpRule() {
		return getNestedExpAccess().getRule();
	}
	
	//VarOrSelfExp returns Exp:
	//    SelfExp | VarReference
	//;
	public VarOrSelfExpElements getVarOrSelfExpAccess() {
		return pVarOrSelfExp;
	}
	
	public ParserRule getVarOrSelfExpRule() {
		return getVarOrSelfExpAccess().getRule();
	}
	
	//SelfExp:
	//    {SelfExp} name='self';
	public SelfExpElements getSelfExpAccess() {
		return pSelfExp;
	}
	
	public ParserRule getSelfExpRule() {
		return getSelfExpAccess().getRule();
	}
	
	//VarDeclaration:
	//    name=SimpleName
	//;
	public VarDeclarationElements getVarDeclarationAccess() {
		return pVarDeclaration;
	}
	
	public ParserRule getVarDeclarationRule() {
		return getVarDeclarationAccess().getRule();
	}
	
	//VarReference: // variable reference
	//    ref=[VarDeclaration]
	//;
	public VarReferenceElements getVarReferenceAccess() {
		return pVarReference;
	}
	
	public ParserRule getVarReferenceRule() {
		return getVarReferenceAccess().getRule();
	}
	
	//PrimitiveLiteralExp:
	//    NumberLiteralExp
	//    | StringLiteralExp
	//    | BooleanLiteralExp
	//    | NullLiteralExp
	//;
	public PrimitiveLiteralExpElements getPrimitiveLiteralExpAccess() {
		return pPrimitiveLiteralExp;
	}
	
	public ParserRule getPrimitiveLiteralExpRule() {
		return getPrimitiveLiteralExpAccess().getRule();
	}
	
	//NumberLiteralExp:
	//    value=INT;
	public NumberLiteralExpElements getNumberLiteralExpAccess() {
		return pNumberLiteralExp;
	}
	
	public ParserRule getNumberLiteralExpRule() {
		return getNumberLiteralExpAccess().getRule();
	}
	
	//StringLiteralExp:
	//    value=STRING;
	public StringLiteralExpElements getStringLiteralExpAccess() {
		return pStringLiteralExp;
	}
	
	public ParserRule getStringLiteralExpRule() {
		return getStringLiteralExpAccess().getRule();
	}
	
	//BooleanLiteralExp:
	//    value='true'
	//    | value='false';
	public BooleanLiteralExpElements getBooleanLiteralExpAccess() {
		return pBooleanLiteralExp;
	}
	
	public ParserRule getBooleanLiteralExpRule() {
		return getBooleanLiteralExpAccess().getRule();
	}
	
	//NullLiteralExp:
	//    {NullLiteralExpCS} 'null';
	public NullLiteralExpElements getNullLiteralExpAccess() {
		return pNullLiteralExp;
	}
	
	public ParserRule getNullLiteralExpRule() {
		return getNullLiteralExpAccess().getRule();
	}
	
	//MethodExp:
	//     PropertyAccess
	//    | MethodCall
	////    | name=IteratorName '(' body=Exp ')'
	//    | CollectionIterator
	//    | TypeCall
	////    | iterSource=OperatorExp '->' iter=IteratorName '(' itervar=IteratorVarDeclaration ',' itervar2=IteratorVarDeclaration '|' body=OperatorExp ')'
	//    //| OperatorExp '->' IteratorName '(' IteratorVarDeclaration ';' InitVarDeclaration '|' OperatorExp ')'
	//    //| OperatorExp '->' IteratorName '(' InitVarDeclaration '|' OperatorExp ')'
	//;
	public MethodExpElements getMethodExpAccess() {
		return pMethodExp;
	}
	
	public ParserRule getMethodExpRule() {
		return getMethodExpAccess().getRule();
	}
	
	//CollectionIterator returns IteratorExp:
	//    name=IteratorName '(' itervar=IteratorVarDeclaration '|' body=Exp ')'
	//;
	public CollectionIteratorElements getCollectionIteratorAccess() {
		return pCollectionIterator;
	}
	
	public ParserRule getCollectionIteratorRule() {
		return getCollectionIteratorAccess().getRule();
	}
	
	//IteratorName:
	//    name=('forAll'|'exists'|'collect'|'reject'|'select');
	public IteratorNameElements getIteratorNameAccess() {
		return pIteratorName;
	}
	
	public ParserRule getIteratorNameRule() {
		return getIteratorNameAccess().getRule();
	}
	
	//IteratorVarDeclaration:
	//    name=VarDeclaration | name=VarDeclaration ':' type=TypeExp;
	public IteratorVarDeclarationElements getIteratorVarDeclarationAccess() {
		return pIteratorVarDeclaration;
	}
	
	public ParserRule getIteratorVarDeclarationRule() {
		return getIteratorVarDeclarationAccess().getRule();
	}
	
	//PropertyAccess returns PropertyAccessExp:
	//    name=SimpleName
	//;
	public PropertyAccessElements getPropertyAccessAccess() {
		return pPropertyAccess;
	}
	
	public ParserRule getPropertyAccessRule() {
		return getPropertyAccessAccess().getRule();
	}
	
	//MethodCall returns MethodCallExp:
	//    name=SimpleName '()'         // operation call
	//    | name=SimpleName '('args=ArgumentsExp')' // operation call
	////    | name=SimpleName '('type=TypeExp')'    // type operation call
	//;
	public MethodCallElements getMethodCallAccess() {
		return pMethodCall;
	}
	
	public ParserRule getMethodCallRule() {
		return getMethodCallAccess().getRule();
	}
	
	//TypeCall returns TypeCallExp:
	//    name=('asType'|'isTypeOf'|'isKindOf')'('type=TypeExp')'
	//;
	public TypeCallElements getTypeCallAccess() {
		return pTypeCall;
	}
	
	public ParserRule getTypeCallRule() {
		return getTypeCallAccess().getRule();
	}
	
	//TypeExp :
	//     {TypeExp} '<' name=Path '>' // eventually we want to replace this with . notated FQN
	//    | collectionType=CollectionTypeIdentifier type=TypeExp;
	public TypeExpElements getTypeExpAccess() {
		return pTypeExp;
	}
	
	public ParserRule getTypeExpRule() {
		return getTypeExpAccess().getRule();
	}
	
	//CollectionTypeIdentifier: // not really used yet, as only needed to define literals
	//    name=('set'|'list'|'map'|'collection')
	//;
	public CollectionTypeIdentifierElements getCollectionTypeIdentifierAccess() {
		return pCollectionTypeIdentifier;
	}
	
	public ParserRule getCollectionTypeIdentifierRule() {
		return getCollectionTypeIdentifierAccess().getRule();
	}
	
	//TemporalExp returns TemporalExp:
	//    UnaryTemporalExp | TriggeredTemporalExp
	//    //| DeclarePatternExp
	//;
	public TemporalExpElements getTemporalExpAccess() {
		return pTemporalExp;
	}
	
	public ParserRule getTemporalExpRule() {
		return getTemporalExpAccess().getRule();
	}
	
	//UnaryTemporalExp:
	//    name=UnaryTemporalOp '(' exp=Exp ')'
	//;
	public UnaryTemporalExpElements getUnaryTemporalExpAccess() {
		return pUnaryTemporalExp;
	}
	
	public ParserRule getUnaryTemporalExpRule() {
		return getUnaryTemporalExpAccess().getRule();
	}
	
	//UnaryTemporalOp:
	//    'next' | 'always' | 'eventually'
	//;
	public UnaryTemporalOpElements getUnaryTemporalOpAccess() {
		return pUnaryTemporalOp;
	}
	
	public ParserRule getUnaryTemporalOpRule() {
		return getUnaryTemporalOpAccess().getRule();
	}
	
	//TriggeredTemporalExp returns TriggeredTemporalExp:
	//    TemporalAsLongAs | TemporalUntil | TemporalEverytime | TemporalAtLeastOnce
	//    | LegacyUntil | LegacyAsSoonAs | LegacyEverytime
	//;
	public TriggeredTemporalExpElements getTriggeredTemporalExpAccess() {
		return pTriggeredTemporalExp;
	}
	
	public ParserRule getTriggeredTemporalExpRule() {
		return getTriggeredTemporalExpAccess().getRule();
	}
	
	///* Alternative Until, interpret: asLongAs(A) ensureThat(B) => as long as A is true, ensure that B is true , A must become true at some time in the future */
	//TemporalAsLongAs returns TriggeredTemporalExp:
	//    name='asLongAs' '(' b=Exp 'ensureThat' a=Exp ')'
	//;
	public TemporalAsLongAsElements getTemporalAsLongAsAccess() {
		return pTemporalAsLongAs;
	}
	
	public ParserRule getTemporalAsLongAsRule() {
		return getTemporalAsLongAsAccess().getRule();
	}
	
	///* Regular Until, interpret: ensureThat(B) asLongAs(A)  => ensure that A is true as long as B is true , B must become true at some time in the future */
	//TemporalUntil returns TriggeredTemporalExp:
	//    name='ensureThat' '(' a=Exp 'asLongAs'  b=Exp ')'
	//;
	public TemporalUntilElements getTemporalUntilAccess() {
		return pTemporalUntil;
	}
	
	public ParserRule getTemporalUntilRule() {
		return getTemporalUntilAccess().getRule();
	}
	
	//TemporalEverytime returns TriggeredTemporalExp:
	//    name='everyTime' '(' a=Exp 'then'  b=Exp ')'
	//;
	public TemporalEverytimeElements getTemporalEverytimeAccess() {
		return pTemporalEverytime;
	}
	
	public ParserRule getTemporalEverytimeRule() {
		return getTemporalEverytimeAccess().getRule();
	}
	
	//TemporalAtLeastOnce returns TriggeredTemporalExp:
	//    name='whenOnce' '(' a=Exp  'thenAtLeastOnce'  b=Exp ')'
	//;
	public TemporalAtLeastOnceElements getTemporalAtLeastOnceAccess() {
		return pTemporalAtLeastOnce;
	}
	
	public ParserRule getTemporalAtLeastOnceRule() {
		return getTemporalAtLeastOnceAccess().getRule();
	}
	
	//LegacyUntil returns TriggeredTemporalExp:
	//    name='until' '('a=Exp ',' b=Exp')'
	//;
	public LegacyUntilElements getLegacyUntilAccess() {
		return pLegacyUntil;
	}
	
	public ParserRule getLegacyUntilRule() {
		return getLegacyUntilAccess().getRule();
	}
	
	//LegacyAsSoonAs returns TriggeredTemporalExp:
	//    name='asSoonAs' '('a=Exp ',' b=Exp')'
	//;
	public LegacyAsSoonAsElements getLegacyAsSoonAsAccess() {
		return pLegacyAsSoonAs;
	}
	
	public ParserRule getLegacyAsSoonAsRule() {
		return getLegacyAsSoonAsAccess().getRule();
	}
	
	//LegacyEverytime returns TriggeredTemporalExp:
	//    name='everytime' '('a=Exp ',' b=Exp')'
	//;
	public LegacyEverytimeElements getLegacyEverytimeAccess() {
		return pLegacyEverytime;
	}
	
	public ParserRule getLegacyEverytimeRule() {
		return getLegacyEverytimeAccess().getRule();
	}
	
	////DeclarePatternExp:
	////    'atMostOnce' |
	////    'bothOrNeither' | // coexistence
	////    'whenever' 'eventually' | // response
	////
	////
	////;
	//Path:
	//     SimpleName ( '/'  SimpleName)*
	//;
	public PathElements getPathAccess() {
		return pPath;
	}
	
	public ParserRule getPathRule() {
		return getPathAccess().getRule();
	}
	
	//ArgumentsExp:
	//    operators+=Exp (',' operators+=Exp)*
	//;
	public ArgumentsExpElements getArgumentsExpAccess() {
		return pArgumentsExp;
	}
	
	public ParserRule getArgumentsExpRule() {
		return getArgumentsExpAccess().getRule();
	}
	
	//terminal ID: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt: ('0'..'9')+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//            '"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
	//            "'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'"
	//        ;
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT : '/*' -> '*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS         : (' '|'\t'|'\r'|'\n')+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER: .;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
