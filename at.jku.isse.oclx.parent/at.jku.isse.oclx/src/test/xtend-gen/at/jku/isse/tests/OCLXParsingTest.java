/**
 * generated by Xtext 2.34.0
 */
package at.jku.isse.tests;

import at.jku.isse.oclx.Model;
import at.jku.isse.oclx.OclxPackage;
import at.jku.isse.validation.OCLXValidator;
import com.google.inject.Inject;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.testing.InjectWith;
import org.eclipse.xtext.testing.extensions.InjectionExtension;
import org.eclipse.xtext.testing.util.ParseHelper;
import org.eclipse.xtext.testing.validation.ValidationTestHelper;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

@ExtendWith(InjectionExtension.class)
@InjectWith(OCLXInjectorProvider.class)
@SuppressWarnings("all")
public class OCLXParsingTest {
  @Inject
  private ParseHelper<Model> parseHelper;

  @Inject
  private ValidationTestHelper validationTestHelper;

  @Test
  public void loadKnownBasicContext() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("rule TestRule {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("description: \"ignored\"");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("context: String");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("expression: self.isDefined() ");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      final Model result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      this.validationTestHelper.assertNoErrors(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", \r\n");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void loadKnownContext() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("rule TestRule {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("description: \"ignored\"");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("context: DemoIssue");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("expression: self.isDefined() ");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      final Model result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      this.validationTestHelper.assertNoErrors(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", \r\n");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void loadUnknownContext() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("rule TestRule {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("description: \"ignored\"");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("context: noSuchType");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("expression: self.isDefined() ");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      final Model result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", \r\n");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
      this.validationTestHelper.assertError(result, 
        OclxPackage.Literals.CONSTRAINT, 
        OCLXValidator.UNKNOWN_TYPE);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void loadSyntacticCorrectSmallModel() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("rule TestRule {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("description: \"testing a better way to provide a description");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("to a rule\"");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("is overrulable: false");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("context: DemoIssue");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("/* some comment here */");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("expression: not(self->FORALL(x : <test/type/decl> | x.isDefined() ) )");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      final Model result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", \r\n");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void loadDuplicateVarDeclaration() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("rule AnotherRule {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("context: nosu");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("expression: self.downstream->FORALL(x | (x.isDefined() ");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t\t\t\t\t");
      _builder.append("and ");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t\t\t\t");
      _builder.append("self->SELECT( x | x.size() > 0)");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t\t\t\t");
      _builder.append(") ");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t\t\t");
      _builder.append(")  ");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      final Model result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      this.validationTestHelper.assertError(result, 
        OclxPackage.Literals.ITERATOR_VAR_DECLARATION, 
        OCLXValidator.DUPLICATE_VAR_NAME);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", \r\n");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void loadKnownPropertyUsage() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("rule TestRule {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("description: \"ignored\"");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("context: DemoIssue");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("expression: self.requirements.size() > 1");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      final Model result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      this.validationTestHelper.assertNoErrors(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", \r\n");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void testFindUnknownTypeDeclaration() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("rule TestRule {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("description: \"testing\"");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("context: DemoIssue");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("expression: not(self.requirements->FORALL(x : <test/type/decl> | x.isDefined() ) )");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      final Model result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      this.validationTestHelper.assertError(result, 
        OclxPackage.Literals.TYPE_EXP, 
        OCLXValidator.UNKNOWN_TYPE);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", \r\n");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void testFindKnownTypeDeclaration() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("rule TestRule {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("description: \"testing\"");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("context: DemoIssue");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("expression: not(self.requirements->FORALL(x : <root/types/DemoIssue> | x.parent <> null ) )");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      final Model result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      this.validationTestHelper.assertNoErrors(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", \r\n");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void testUpcastVariable() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("rule TestRule {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("description: \"testing\"");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("context: artifact");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("expression: self.asType(<root/types/DemoIssue>).requirements.size() > 0 ");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      final Model result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      this.validationTestHelper.assertNoErrors(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", \r\n");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void testDowncastVariable() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("rule TestRule {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("description: \"testing\"");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("context: DemoIssue");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("expression: self.asType(<root/types/artifact>).requirements.size() > 0 ");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      final Model result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      this.validationTestHelper.assertError(result, 
        OclxPackage.Literals.PROPERTY_ACCESS_EXP, 
        OCLXValidator.UNKNOWN_PROPERTY);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", \r\n");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
}
